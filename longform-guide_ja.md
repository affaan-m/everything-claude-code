# The Longform Guide to Everything Claude Code - 日本語版

**原文：[@affaanmustafa](https://x.com/affaanmustafa/status/2014040193557471352)**

上級テクニック編 - トークン最適化、セッション間のメモリ永続化、検証ループと評価、並列化戦略、サブエージェントオーケストレーション、継続的学習。

---

## 目次

1. [トークン最適化](#1-トークン最適化)
2. [メモリ永続化](#2-メモリ永続化)
3. [継続的学習](#3-継続的学習)
4. [検証ループ](#4-検証ループ)
5. [並列化](#5-並列化)
6. [サブエージェントオーケストレーション](#6-サブエージェントオーケストレーション)

---

## 1. トークン最適化

### コンテキストウィンドウの真実

- **auto-compact の罠**: auto-compactは大量のコンテキストウィンドウを静かに消費する
- 報告によると、autocompactバッファが**45kトークン（コンテキストウィンドウの22.5%）**を消費することも
- コーディングを始める前にすでに消費されている

### モデル選択戦略

| タスク | 推奨モデル | 理由 |
|--------|-----------|------|
| 複雑な設計・アーキテクチャ | Opus | 高い推論能力 |
| 一般的なコーディング | Sonnet | バランスが良い |
| 単純なタスク・探索 | Haiku | 高速・低コスト |

### システムプロンプトのスリム化

- 不要なルールを削除
- 重複する指示を統合
- プロジェクト固有の情報のみを含める

### 75%ルール

> セッションを75%の利用率で停止すると、総出力は少なくなるが、**より高品質で保守しやすいコード**が生成される

コンテキスト管理を保守的に行うことで、以下が向上：
- レスポンス品質
- 推論能力
- アーキテクチャ判断

---

## 2. メモリ永続化

### コンパクション問題

Claude Codeにはコンパクション問題がある：
- コンテキストが満杯になると、システムが会話をコンパクト化
- セッション中に行われた微妙な理解や決定が失われる

### 解決策：「Compound, don't compact」

コンパクトするのではなく、**複合（Compound）**する：
1. 学習内容を自動抽出
2. フルコンテキストで新しいセッションを開始

### セッションライフサイクルフック

```
hooks/memory-persistence/
├── session-start.sh    # セッション開始時にコンテキストを読み込み
├── pre-compact.sh      # コンパクト前に状態を保存
└── session-end.sh      # セッション終了時に学習を保存
```

### 主要なフックイベント

| フック | タイミング | 用途 |
|--------|-----------|------|
| `SessionStart` | セッション開始時 | 開発コンテキストを自動読み込み |
| `PreCompact` | コンパクト前 | メモリが満杯になる前に状態を保存 |
| `SubagentStop` | サブエージェント終了時 | タスク完了を検知 |
| `UserPromptSubmit` | プロンプト送信時 | 処理前にトリガー |

### セッション再開

```bash
# 前のセッションを再開
claude --resume

# 特定のセッションを続行
claude --continue
```

**活用例**: 数日前のセッションを再開し、特定のエラーをどう克服したかを要約させ、それをCLAUDE.mdや内部ツールの改善に使用。

---

## 3. 継続的学習

### 自動パターン抽出

Claudeが以下を発見したとき、新しいスキルとして保存：
- デバッグテクニック
- ワークアラウンド
- プロジェクト固有のパターン

次回同様の問題が発生したとき、スキルが自動的に読み込まれる。

### スキル抽出の条件

以下の場合にのみ抽出：
1. ✅ 実際の発見が必要だった（ドキュメントを読むだけではない）
2. ✅ 将来のタスクに役立つ
3. ✅ 明確なトリガー条件がある
4. ✅ 動作が検証済み

### 抽出トリガー

スキルは以下の場合に自動的に活性化：
- デバッグを完了し、非自明な解決策を発見
- 調査を通じてワークアラウンドを発見
- 根本原因が明らかでないエラーを解決
- プロジェクト固有のパターンを学習

### フックによる学習リマインダー

```json
{
  "event": "UserPromptSubmit",
  "hooks": [{
    "type": "command",
    "command": "echo '[Learning] 現在のタスクから抽出可能な知識があるか評価してください'"
  }]
}
```

プロンプトごとにリマインダーを注入し、意味的な記述マッチングに頼るより高い活性化率を達成。

---

## 4. 検証ループ

### チェックポイント vs 継続評価

| アプローチ | 説明 | 適用場面 |
|-----------|------|---------|
| **チェックポイント** | 特定ポイントで状態を保存・検証 | マイルストーンベースの開発 |
| **継続評価** | 常時評価を実行 | CI/CDパイプライン |

### チェックポイント機能

Claude Codeのチェックポイントで可能なこと：
- 会話を保持したまま、ファイル変更をリバート
- コードと会話の両方を以前のポイントに復元

**注意点**:
- Claude のファイル編集ツールによる直接編集のみが追跡される
- 現在のセッション内で編集されたファイルのみが追跡される
- チェックポイントは Git を**補完**するもので、**置き換え**るものではない

### pass@k メトリクス

評価駆動開発（EDD）フレームワークで使用：

| メトリクス | 説明 |
|-----------|------|
| **pass@1** | 1回の試行で正解する確率 |
| **pass@3** | 3回の試行で少なくとも1回正解する確率 |
| **pass@k** | k回の試行で少なくとも1回正解する確率 |

### グレーダータイプ

- **自動グレーダー**: テストスイート、リンター、型チェッカー
- **LLMグレーダー**: AI による品質評価
- **人間グレーダー**: 手動レビュー

---

## 5. 並列化

### なぜ並列化か

現在のAIコーディングツールの問題：
- タスク完了後に停止
- 自己批評や改善の機会がない
- ワンショットパターンでは大規模プロジェクトが困難

### Git Worktrees

競合なしで複数のClaudeを並列実行：

```bash
# ワークツリーを作成
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b

# 各ワークツリーで別々のClaudeセッションを実行
cd ../project-feature-a && claude
cd ../project-feature-b && claude
```

各ワークツリーは独立したチェックアウト。

### カスケードメソッド

1. 最初のClaudeがタスクを完了
2. 結果を次のClaudeに渡す
3. 次のClaudeがレビュー・改善
4. 繰り返し

### /fork コマンド

会話をフォークして、重複しないタスクを並列実行：
- キューにメッセージを溜めるより効率的
- 独立したタスクに最適

### インスタンスをスケールするタイミング

| シナリオ | 推奨 |
|---------|------|
| 独立したタスクが複数 | 並列化 |
| 依存関係のあるタスク | 順次実行 |
| 大規模リファクタリング | Git Worktrees |
| 探索と実装の分離 | サブエージェント |

### 継続ループパターン

CI/CDにインスパイアされたパターン：
- スケジュールまたはトリガーでClaude Codeを実行
- GitHub PRワークフローに接続
- 前の反復からのコンテキストと結果を永続化
- 以前のステップで得た知識が失われない

---

## 6. サブエージェントオーケストレーション

### コンテキスト問題

メインの会話でのすべての探索と実装は：
- コンテキストウィンドウを急速に消費
- 重要な情報が押し出される
- パフォーマンスが低下

### サブエージェントの利点

1. **コンテキストの保護**: 探索と実装をメイン会話から分離
2. **制約の強制**: サブエージェントが使用できるツールを制限
3. **設定の再利用**: ユーザーレベルのサブエージェントでプロジェクト間で再利用
4. **コスト制御**: Haikuなどの安価なモデルにタスクをルーティング

### サブエージェントの仕組み

各サブエージェントは独自の：
- コンテキストウィンドウ
- カスタムシステムプロンプト
- 特定のツールアクセス
- 独立した権限

を持つ。

### 反復的取得パターン

```
1. メインエージェントがタスクを分析
2. 適切なサブエージェントに委任
3. サブエージェントが調査・実行
4. 結果をメインエージェントに返す
5. メインエージェントが統合・次のステップを決定
```

### Master-Clone アーキテクチャ（代替案）

カスタムサブエージェントの代わりに：
1. すべてのコンテキストを CLAUDE.md に配置
2. メインエージェントの Task/Explore 機能で委任を管理
3. 固定的な専門家定義を避ける

### ベストプラクティス：分割統治

> サブエージェントで分割統治：大きな目標をモジュール化。API調査、セキュリティレビュー、機能計画を専門のサブエージェントに委任。

各サブエージェントが独自のコンテキストウィンドウを持つため、単一のセッションが限界に近づくことを防ぐ。

---

## まとめ

### 重要原則

1. **コンテキストは貴重** - 75%ルールを守り、不要な消費を避ける
2. **コンパクトより複合** - 学習を抽出し、フレッシュスタート
3. **継続的に学習** - パターンをスキルとして保存
4. **検証を組み込む** - チェックポイントとpass@kで品質を保証
5. **並列化で効率化** - Git Worktrees、/fork、カスケード
6. **サブエージェントで分割** - コンテキストを保護し、専門性を活用

---

## 参考リンク

- [原文（X/Twitter）](https://x.com/affaanmustafa/status/2014040193557471352)
- [GitHub - affaan-m/everything-claude-code](https://github.com/affaan-m/everything-claude-code)
- [Claude Code Docs - Subagents](https://code.claude.com/docs/en/sub-agents)
- [Claude Code Docs - Checkpointing](https://code.claude.com/docs/en/checkpointing)
- [GitHub - Claudeception (Continuous Learning)](https://github.com/blader/Claudeception)
- [GitHub - Continuous-Claude-v3](https://github.com/parcadei/Continuous-Claude-v3)
